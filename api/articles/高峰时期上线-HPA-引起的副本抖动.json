{"title":"高峰时期上线 HPA 引起的副本抖动","uid":"7217aeb6d9a4e768dbd053e0d0297223","slug":"高峰时期上线-HPA-引起的副本抖动","date":"2022-08-11T13:11:00.000Z","updated":"2022-08-22T11:08:41.071Z","comments":true,"path":"api/articles/高峰时期上线-HPA-引起的副本抖动.json","keywords":"coding","cover":[],"content":"<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>我们在引入<code>kubernetes</code>的<code>hpa</code>功能后,高峰时期上线我们的<code>pod</code>副本数会缩小到<code>replicas</code>指定的数量后,然后<code>hpa</code>又会开始扩容,这个时候我们的<code>pod</code>无法支撑<br>请求数,会出现大量的超时.等到<code>hpa</code>扩容后会恢复,导致高峰时期不敢轻易上线.</p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>没有<code>hpa</code>之前,我们的副本数量由<code>replicas</code>参数控制,假如设置<code>replicas:2</code>,那么我们的<code>pod</code>副本数就一直都是 2 个.除非我们手动进行扩容.<br>引入<code>hpa</code>后,副本数会由<code>hpa</code>的<code>minReplicas</code>和<code>maxReplicas</code>控制.发布的时候会先平衡到<code>replicas</code>的值,然后<code>hpa</code>会根据配置动态的修改<code>replicas</code>值来控制<code>pod</code>的副本数.<br>假如<code>hpa</code>后我们的副本数为:<code>4</code>,大于初始值<code>replicas:2</code>的值了.那么发布的时候就会先缩小到<code>replicas:2</code>的值.再扩容到发布前的副本数:<code>4</code>,这个时候就会出现副本数的抖动.</p>\n<h1 id=\"演示图\"><a href=\"#演示图\" class=\"headerlink\" title=\"演示图\"></a>演示图</h1><p><img src=\"/images/pasted-12.png\" alt=\"upload successful\"></p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>使用<code>hpa</code>后删除所有<code>deployments</code>里面设置的初始的<code>replicas</code>节点.不设置<code>replicas</code>,那么发布的时候,会根据当前的数量按照设置的更新策略进行.而不是先恢复到<code>replicas</code>的值.<br>那么这个时候初始的副本数则有<code>minReplicas</code>控制.</p>\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>当我们使用滚动更新的时候,要保证副本数最小的可用副本数.不能把所有的副本都<code>Terminating</code>了.这样会引起服务异常.<br>尤其是我们在开发测试环境的时候.由于请求量不大,往往副本数只有一个.当我们滚动更新的时候,可能会导致副本数清零,再启动新副本.</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">\nstrategy:\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n    type: RollingUpdate\n</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">通俗讲</p>\n<p><ul>\n<li><code>maxSure</code> 控制加的行为,每次新增多少个副本.可以为整数和百分比</li>\n<li><code>maxUnavailable</code> 控制减的行为, 表示最多不可用的数量</li>\n</ul>\n</p>\n</div>\n<p><code>strategy</code>（更新策略）：<br>　　<code>.spec.strategy</code> 指定新的Pod替换旧的Pod的策略。 <code>.spec.strategy.type</code> 可以是<code>Recreate</code>或者是 <code>RollingUpdate</code>。<code>RollingUpdate</code>是默认值。</p>\n<p>　　<code>Recreate</code>： 重建式更新，就是删一个建一个。类似于<code>ReplicaSet</code>的更新方式，即首先删除现有的Pod对象，然后由控制器基于新模板重新创建新版本资源对象。</p>\n<p>　　<code>rollingUpdate</code>：滚动更新，简单定义 更新期间<code>pod</code>最多有几个等。可以指定<code>maxUnavailable</code> 和 <code>maxSurge</code> 来控制 <code>rolling update</code> 进程。</p>\n<p>　　<code>maxSurge</code>：.spec.strategy.rollingUpdate.maxSurge 是可选配置项，用来指定可以超过期望的Pod数量的最大个数。该值可以是一个绝对值（例如5）或者是期望的Pod数量的百分比（例如10%）。当        <code>MaxUnavailable</code>为0时该值不可以为0。通过百分比计算的绝对值向上取整。默认值是1。</p>\n<p>　　例如，该值设置成30%，启动rolling update后新的<code>ReplicatSet</code>将会立即扩容，新老Pod的总数不能超过期望的Pod数量的130%。旧的Pod被杀掉后，新的<code>ReplicaSet</code>将继续扩容，旧的<code>ReplicaSet</code>会进一步缩容，确保在升级的所有时刻所有的Pod数量和不会超过期望Pod数量的130%。</p>\n<p>　　<code>maxUnavailable</code>：.spec.strategy.rollingUpdate.maxUnavailable 是可选配置项，用来指定在升级过程中不可用Pod的最大数量。该值可以是一个绝对值（例如5），也可以是期望Pod数量的百分比（例如10%）。通过计算百分比的绝对值向下取整。  如果.spec.strategy.rollingUpdate.maxSurge 为0时，这个值不可以为0。默认值是1。</p>\n<p>　　例如，该值设置成30%，启动rolling update后旧的<code>ReplicatSet</code>将会立即缩容到期望的Pod数量的70%。新的Pod ready后，随着新的<code>ReplicaSet</code>的扩容，旧的<code>ReplicaSet</code>会进一步缩容确保在升级的所有时刻可以用的Pod数量至少是期望Pod数量的70%。</p>\n<p>PS：<code>maxSurge</code>和<code>maxUnavailable</code>的属性值不可同时为0，否则Pod对象的副本数量在符合用户期望的数量后无法做出合理变动以进行更新操作。</p>\n<p>　　在配置时，用户还可以使用<code>Deployment</code>控制器的<code>spec.minReadySeconds</code>属性来控制应用升级的速度。新旧更替过程中，新创建的<code>Pod</code>对象一旦成功响应就绪探测即被认为是可用状态，然后进行下一轮的替换。而<code>spec.minReadySeconds</code>能够定义在新的Pod对象创建后至少需要等待多长的时间才能会被认为其就绪，在该段时间内，更新操作会被阻塞。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">给个稳妥的配置,开发测试环境妥妥的</p>\n<ul>\n<li><code>maxSure:1</code> 一个一个滚动更新,就是发布慢了点.</li>\n<li><code>maxUnavailable:0</code> 至少有一个副本在运行</li>\n</ul>\n\n</div>\n","feature":true,"text":"现象我们在引入kubernetes的hpa功能后,高峰时期上线我们的pod副本数会缩小到replicas指定的数量后,然后hpa又会开始扩容,这个时候我们的pod无法支撑请求数,会出现大量的超时.等到hpa扩容后会恢复,导致高峰时期不敢轻易上线. 原因没有hpa之前,我们的副本数...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"kubernetes","slug":"kubernetes","count":2,"path":"api/categories/kubernetes.json"}],"tags":[{"name":"kubernetes","slug":"kubernetes","count":2,"path":"api/tags/kubernetes.json"},{"name":"hpa","slug":"hpa","count":1,"path":"api/tags/hpa.json"},{"name":"pod","slug":"pod","count":1,"path":"api/tags/pod.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">现象</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">原因</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BC%94%E7%A4%BA%E5%9B%BE\"><span class=\"toc-text\">演示图</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">解决办法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E5%A4%96%E8%AF%9D\"><span class=\"toc-text\">题外话</span></a></li></ol>","author":{"name":"tusimo","slug":"tusimo","avatar":"https://avatars.githubusercontent.com/u/4344635?v=4","link":"https://github.com/tusimo","description":"Think like an artist, code like an artisan.","socials":{"github":"https://tusimo.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"腾讯云 redis 迁移AWS的若干问题","uid":"5787a32e0acc329c90bb7d6138b83d3a","slug":"腾讯云-redis-迁移AWS的若干问题","date":"2022-08-22T07:09:00.000Z","updated":"2022-08-22T11:08:41.071Z","comments":true,"path":"api/articles/腾讯云-redis-迁移AWS的若干问题.json","keywords":"coding","cover":null,"text":"redis 迁移全量迁移 全量迁移比较简单,可以采用以下两种方式进行迁移. 1 rdb 导入导出 2 scan keys 进行同步 以上方式可以通过 redis-shake实现. 使用比较简单,可以参考官方文档进行配置. 增量迁移 增量迁移可以通过以下方式进行 1 通过PSYNC...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"},{"name":"腾讯云","slug":"腾讯云","count":1,"path":"api/tags/腾讯云.json"},{"name":"redis-shake","slug":"redis-shake","count":1,"path":"api/tags/redis-shake.json"},{"name":"riot-redis","slug":"riot-redis","count":1,"path":"api/tags/riot-redis.json"}],"author":{"name":"tusimo","slug":"tusimo","avatar":"https://avatars.githubusercontent.com/u/4344635?v=4","link":"https://github.com/tusimo","description":"Think like an artist, code like an artisan.","socials":{"github":"https://tusimo.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"php 容器化的几点建议","uid":"b14c7bb0c256981c822f52d59e144945","slug":"php-容器化的几点建议","date":"2022-08-10T10:15:00.000Z","updated":"2022-08-22T11:08:41.071Z","comments":true,"path":"api/articles/php-容器化的几点建议.json","keywords":"coding","cover":"https://images.pexels.com/photos/1044990/pexels-photo-1044990.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1","text":"镜像编译基础镜像编译github repo 基础镜像编译使用环境变量替换配置. FROM php:7.2-fpm-alpine # replace repositories RUN sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mi...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"kubernetes","slug":"kubernetes","count":2,"path":"api/categories/kubernetes.json"},{"name":"php","slug":"kubernetes/php","count":1,"path":"api/categories/kubernetes/php.json"}],"tags":[{"name":"php","slug":"php","count":1,"path":"api/tags/php.json"},{"name":"kubernetes","slug":"kubernetes","count":2,"path":"api/tags/kubernetes.json"},{"name":"nginx","slug":"nginx","count":1,"path":"api/tags/nginx.json"},{"name":"docker","slug":"docker","count":1,"path":"api/tags/docker.json"}],"author":{"name":"tusimo","slug":"tusimo","avatar":"https://avatars.githubusercontent.com/u/4344635?v=4","link":"https://github.com/tusimo","description":"Think like an artist, code like an artisan.","socials":{"github":"https://tusimo.github.io","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}